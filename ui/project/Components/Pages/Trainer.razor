@page "/"
@using DiffusionPipeInterface.Database
@using DiffusionPipeInterface.Enums
@using DiffusionPipeInterface.Models
@using DiffusionPipeInterface.Models.Models
@using DiffusionPipeInterface.Models.Process
@using DiffusionPipeInterface.Services
@using DiffusionPipeInterface.ViewModels
@using DiffusionPipeInterface.ViewModels.Models
@using Microsoft.EntityFrameworkCore
@using System.Text.RegularExpressions
@using Microsoft.Extensions.Options
@using Tomlyn
@using Tomlyn.Model
@using Utils
@inject IDbContextFactory<AppDbContext> dbContextFactory;
@inject ISnackbar Snackbar
@inject IOptionsMonitor<AppSettingsConfiguration> Configuration
@inject ProcessManager ProcessManager
@inject IJSRuntime JSRuntime
@inject FolderMonitorService FolderMonitorService
@inject InterfaceControlViewModel InterfaceControl
@inject IDialogService DialogService
@inject ReconnectionService ReconnectionService

@implements IDisposable

<MudContainer Fixed="true">
    <MudGrid Spacing="10">
        <MudItem xs="12">
            <DatasetDirectoryConfiguration @ref="datasetDirectoryConfigurationRef" TrainConfiguration="TrainConfiguration" ConfigsChanged="HandleUpdateConfigs"></DatasetDirectoryConfiguration>
        </MudItem>
        <MudItem xs="12">
            <MudForm @ref="trainingForm">
                <MudGrid Spacing="10">
                    <MudItem xs="12">
                        <ModelsParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></ModelsParametersConfiguration>
                    </MudItem>
                    <MudItem xs="12">
                        <TrainingParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></TrainingParametersConfiguration>
                    </MudItem>
                    <MudItem xs="12">
                        <OptimizerParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></OptimizerParametersConfiguration>
                    </MudItem>
                    <MudItem xs="12">
                        <AdapterParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></AdapterParametersConfiguration>
                    </MudItem>
                    @if (config.UsingDiffusionPipeFromFork)
                    {
                        <MudItem xs="12">
                            <MonitoringParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></MonitoringParametersConfiguration>
                        </MudItem>
                    }
                    <MudItem xs="12">
                        <ExtraParametersConfiguration Locked="InterfaceControl.TrainingLocked" TrainConfiguration="TrainConfiguration"></ExtraParametersConfiguration>
                    </MudItem>
                    <MudItem xs="12">
                        <MudCard>
                            <MudCardHeader>
                                <CardHeaderContent>
                                    <MudText Typo="Typo.h6">Controls</MudText>
                                </CardHeaderContent>
                            </MudCardHeader>
                            <MudCardContent>
                                <MudGrid>
                                    <MudItem xs="4">
                                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" Disabled="isTraining" FullWidth="true" OnClick="StartTrainingAsync">Start Training</MudButton>
                                    </MudItem>
                                    <MudItem xs="4">
                                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Disabled="!isTraining" FullWidth="true" OnClick="StopTrainingAsync">Stop Training</MudButton>
                                    </MudItem>
                                    <MudItem xs="4">
                                        <MudButton Variant="Variant.Outlined" Color="Color.Default" Disabled="!isTraining" FullWidth="true" OnClick="ForceSaveCheckpoint">Force Save Checkpoint</MudButton>
                                    </MudItem>
                                    <MudItem xs="12">
                                        <MudPaper Class=" pa-4 align-start d-flex" Outlined="true">
                                            <MudPaper Class="pa-3" Elevation="6">Steps: @InterfaceControl.CurrentStep / @InterfaceControl.TotalSteps</MudPaper>
                                            <MudPaper Class="pa-3" Elevation="6">Steps per Epoch: @InterfaceControl.StepsPerEpoch</MudPaper>
                                            <MudPaper Class="pa-3" Elevation="6">Epochs: @InterfaceControl.CurrentEpoch / @TrainConfiguration.Epochs</MudPaper>
                                        </MudPaper>
                                    </MudItem>
                                    <MudItem xs="12">
                                        <MudProgressLinear Color="Color.Tertiary" Size="Size.Large" Value="@InterfaceControl.ProgressValueTrain" />
                                    </MudItem>
                                </MudGrid>
                            </MudCardContent>
                        </MudCard>
                        @* <AlarmComponent/> *@
                    </MudItem>
                </MudGrid>
            </MudForm>
        </MudItem>
        <MudItem xs="12">
            <MudTextField T="string" @ref=logOutputRef @bind-Value="outputText" Label="Output Logs" Typo="Typo.body2" ReadOnly="true" Variant="Variant.Outlined" Lines="50" MaxLines="Int32.MaxValue" />
        </MudItem>
    </MudGrid>
</MudContainer>

<MudScrollToTop>
    <MudFab Color="Color.Tertiary" StartIcon="@Icons.Material.Filled.ArrowCircleUp" />
</MudScrollToTop>
@code {
    #nullable enable
    private bool isUploading = false;
    private string outputText { get; set; } = string.Empty;
    private bool isTraining { get; set; } = false;
    private Guid? processId;
    private bool isInitialized = false;
    private MudTextField<string> logOutputRef;
    private Components.DatasetDirectoryConfiguration datasetDirectoryConfigurationRef = null!;
    private FileTreeView outputTreeViewRef = null!;

    private AppSettingsConfiguration config;

    private ModelType modelType = ModelType.SDXL;

    private List<string> _files = new List<string>();

    public TrainConfigurationViewModel TrainConfiguration { get; set; } = new();

    private MudForm trainingForm = new();

    protected override void OnInitialized()
    {
        config = Configuration.CurrentValue;
        FolderMonitorService.OnNewSubfolderCreated += HandleNewFile;

        ReconnectionService.Reconnected += OnReconnected;
    }

    private async void OnReconnected()
    {
        await CheckProcessStatusAsync();
        Console.WriteLine("Reconnected! State restored.");
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            processId = await GetProcessIdFromLocalStorageAsync();
            if (processId.HasValue)
            {
                await CheckProcessStatusAsync();
            }

            ProcessManager.LogReceived += OnLogReceived;
            ProcessManager.ProcessCompleted += OnProcessCompleted;

            isInitialized = true;
        }
    }

    private void OnLogReceived(object sender, ProcessLogEventArgs e)
    {
        if (e.ProcessId == processId)
        {
            if (config.UsingDiffusionPipeFromFork)
            {
                if (!string.IsNullOrEmpty(e.Log) && e.Log.Contains("Total steps:"))
                {
                    string[] totalStepsParts = e.Log.Split(new string[] { "Total steps:" }, StringSplitOptions.None);
                    if (totalStepsParts.Length > 1)
                    {
                        string totalStepsString = totalStepsParts[1].Trim();
                        if (int.TryParse(totalStepsString, out int totalSteps))
                        {
                            InterfaceControl.TotalSteps = totalSteps;
                        }
                        else
                        {
                            Console.WriteLine($"Error parsing total steps value: '{totalStepsString}'");
                        }
                    }
                }

                if (!string.IsNullOrEmpty(e.Log) && e.Log.Contains("Steps per epoch:"))
                {
                    string[] stepsPerEpochParts = e.Log.Split(new string[] { "Steps per epoch:" }, StringSplitOptions.None);
                    if (stepsPerEpochParts.Length > 1)
                    {
                        string stepsPerEpochString = stepsPerEpochParts[1].Trim();
                        if (int.TryParse(stepsPerEpochString, out int stepsPerEpoch))
                        {
                            InterfaceControl.StepsPerEpoch = stepsPerEpoch;
                        }
                        else
                        {
                            Console.WriteLine($"Error parsing steps per epoch value: '{stepsPerEpochString}'");
                        }
                    }
                }
            }

            if (!string.IsNullOrEmpty(e.Log) && e.Log.Contains("step="))
            {
                string[] stepParts = e.Log.Split(new string[] { "step=" }, StringSplitOptions.None);
                if (stepParts.Length > 1)
                {
                    string[] valueParts = stepParts[1].Split(',');
                    if (valueParts.Length > 0)
                    {
                        string stepString = valueParts[0].Trim();
                        if (int.TryParse(stepString, out int currentStep))
                        {
                            InterfaceControl.CurrentStep = currentStep;
                        }
                        else
                        {
                            Console.WriteLine($"Error parsing step value: '{stepString}'");
                        }
                    }
                }
            }

            if (!string.IsNullOrEmpty(e.Log) && e.Log.Contains("Started new epoch:"))
            {
                string[] epochParts = e.Log.Split(new string[] { "Started new epoch:" }, StringSplitOptions.None);
                if (epochParts.Length > 1)
                {
                    string epochString = epochParts[1].Trim();
                    if (int.TryParse(epochString, out int currentEpoch))
                    {
                        InterfaceControl.CurrentEpoch = currentEpoch;
                    }
                    else
                    {
                        Console.WriteLine($"Error parsing epoch value: '{epochString}'");
                    }
                }
            }

            InterfaceControl.ProgressValueTrain = TrainConfiguration.Epochs == 0 ? 0 : (InterfaceControl.CurrentEpoch / TrainConfiguration.Epochs) * 100;

            outputText += $"{e.Log}\n";
            InvokeAsync(StateHasChanged);
        }

        JSRuntime.InvokeVoidAsync("scrollToBottom", logOutputRef?.InputReference?.ElementReference);
    }


    private void OnProcessCompleted(object sender, Guid completedProcessId)
    {
        if (completedProcessId == processId)
        {
            isTraining = false;
            StateHasChanged();
        }
    }

    private async Task CheckProcessStatusAsync()
    {
        if (processId.HasValue)
        {
            var processInfo = ProcessManager.GetProcessInfo(processId.Value);

            if (processInfo != null)
            {
                outputText = string.Join("\n", processInfo.Logs);

                if (!processInfo.IsRunning)
                {
                    await ClearProcessIdFromLocalStorageAsync();
                    processId = null;
                }
                else
                {
                    var datasetPath = Path.Combine(config.ConfigsPath!, processInfo.DatasetName);
                    var dataset = FileHelper.GetDatasetConfiguration(datasetPath);

                    if (datasetDirectoryConfigurationRef != null && dataset != null && TrainConfiguration.DatasetConfig == null)
                    {
                        datasetDirectoryConfigurationRef.DatasetOption = "Select";
                        datasetDirectoryConfigurationRef.DatasetSelected = dataset!;
                        // InterfaceControl.DatasetSelectedLocked && datasetOption == "Select")
                        await datasetDirectoryConfigurationRef.LoadDatasetAsync(dataset);
                    }

                    isTraining = true;
                }
            }
            else
            {
                await ClearProcessIdFromLocalStorageAsync();
                processId = null;
            }
        }
    }

    private async Task<Guid?> GetProcessIdFromLocalStorageAsync()
    {
        var processIdString = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "processId");
        if (Guid.TryParse(processIdString, out var processId))
        {
            return processId;
        }
        return null;
    }

    private async Task SaveProcessIdToLocalStorageAsync(Guid processId)
    {
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "processId", processId.ToString());
    }

    private async Task ClearProcessIdFromLocalStorageAsync()
    {
        await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "processId");
    }

    private async Task StartTrainingAsync()
    {
        await trainingForm.Validate();


        if (trainingForm.IsValid)
        {

            try
            {
                if (TrainConfiguration.DatasetConfig == null && TrainConfiguration.OutputDir == null)
                {
                    await datasetDirectoryConfigurationRef.SaveDatasetConfiguration();
                }

                var trainToml = TrainConfiguration.GenerateToml();

                var datasetName = datasetDirectoryConfigurationRef.DatasetsConfigurations.Name;

                var trainPath = Path.Combine(config.ConfigsPath!, datasetName, "config.toml");

                FileHelper.SaveToml(trainToml, trainPath);

                isTraining = true;
                outputText = "Starting training...\n";

                InterfaceControl.ProgressValueTrain = 0;
                InterfaceControl.CurrentStep = 0;
                InterfaceControl.CurrentEpoch = 0;
                InterfaceControl.StepsPerEpoch = 0;

                var command = config.StartTrainingCommand;
                command = command.Replace("{EnvPath}", config.EnvPath)
                            .Replace("{DiffusionPipePath}", config.DiffusionPipePath)
                            .Replace("{TrainConfig}", trainPath);

                var numGpus = Environment.GetEnvironmentVariable("NUM_GPUS");

                if (numGpus != null && int.TryParse(numGpus, out var numGpusInt))
                {
                    Console.WriteLine($"DPI - NUM_GPUS: {numGpusInt}");
                    string pattern = @"--num_gpus\s*=\s*\S+";
                    command = Regex.Replace(command, pattern, $"--num_gpus={numGpusInt}");
                }

                if(TrainConfiguration.ResumeFromCheckpoint)
                {
                    if (!string.IsNullOrEmpty(TrainConfiguration.ResumeFromSpecificCheckpoint))
                    {
                        command += $" --resume_from_checkpoint \"{TrainConfiguration.ResumeFromSpecificCheckpoint}\"";
                    }
                    else
                    {
                        command += $@" --resume_from_checkpoint";
                    }
                }

                if (!Directory.Exists(TrainConfiguration.OutputDir))
                {
                    Directory.CreateDirectory(TrainConfiguration.OutputDir);
                }

                FolderMonitorService.SetFolderPath(TrainConfiguration.OutputDir);

                processId = ProcessManager.StartProcess(command, config.DiffusionPipePath, datasetName);

                await SaveProcessIdToLocalStorageAsync(processId.Value);

                await CheckProcessStatusAsync();
            }
            catch (Exception ex)
            {
                outputText += $"Error: {ex.Message}\n";
                isTraining = false;
            }
        }
    }

    private async Task StopTrainingAsync()
    {
        if (processId.HasValue)
        {
            var processInfo = ProcessManager.GetProcessInfo(processId.Value);
            if (processInfo != null && processInfo.IsRunning)
            {
                ProcessManager.StopProcess(processId.Value);
                await ClearProcessIdFromLocalStorageAsync();
                processId = null;
                outputText += "Training interrupted.\n";
                isTraining = false;
                StateHasChanged();
            }
        }
    }

    private async Task ForceSaveCheckpoint()
    {
        bool? result = await DialogService.ShowMessageBox(
           "Warning",
           "Make sure your training is in progress (when you already have the steps incrementing), if you force the checkpoint save without this condition you will probably have errors.",
           yesText: "Force!", cancelText: "Cancel");

        if (result == true)
        {
            FileHelper.ForceSave(TrainConfiguration.OutputDir, "save");
        }
    }

    private void HandleNewFile(string filePath)
    {
        _files.Add(filePath);
        InvokeAsync(StateHasChanged);
    }

    private string GetDownloadLink(string filePath)
    {
        return $"/download?file={Uri.EscapeDataString(filePath)}";
    }

    private async Task HandleUpdateConfigs(TrainConfigurationViewModel trainConfig)
    {
        TrainConfiguration = trainConfig;
        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        ProcessManager.LogReceived -= OnLogReceived;
        FolderMonitorService.OnNewSubfolderCreated -= HandleNewFile;
    }
}